// >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
// ------------------------------------------------------------------
// Copyright (c) 2019-2024 by Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// ------------------------------------------------------------------
//
// IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPELâ„¢
// DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.
//
// Lattice grants permission to use this code pursuant to the
// terms of the Lattice Propel License Agreement.
//
// DISCLAIMER:
//
//  LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS, WHETHER
//  EXPRESSED, IMPLIED, STATUTORY, OR IN ANY PROVISION OF THE LATTICE
//  PROPEL LICENSE AGREEMENT OR COMMUNICATION WITH LICENSEE, AND LATTICE 
//  SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY OR
//  FITNESS FOR A PARTICULAR PURPOSE.  LATTICE DOES NOT WARRANT THAT THE
//  FUNCTIONS CONTAINED HEREIN WILL MEET LICENSEE'S REQUIREMENTS, OR THAT
//  LICENSEE'S OPERATION OF ANY DEVICE, SOFTWARE OR SYSTEM USING THIS FILE
//  OR ITS CONTENTS WILL BE UNINTERRUPTED OR ERROR FREE, OR THAT DEFECTS
//  HEREIN WILL BE CORRECTED.  LICENSEE ASSUMES RESPONSIBILITY FOR 
//  SELECTION OF MATERIALS TO ACHIEVE ITS INTENDED RESULTS, AND FOR THE
//  PROPER INSTALLATION, USE, AND RESULTS OBTAINED THEREFROM.  LICENSEE
//  ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING DEFECTIVE
//  OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT, LICENSEE SHALL 
//  ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE, CORRECTION, OR
//  ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE 
//  SOFTWARE.  IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
//  INDIRECT,SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST
//  PROFITS, ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS, EVEN IF
//  LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. LATTICE'S
//  SOLE LIABILITY, AND LICENSEE'S SOLE REMEDY, IS SET FORTH ABOVE.  
//  LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE, ITS CONTENTS OR
//  USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES' INTELLECTUAL PROPERTY
//  RIGHTS, INCLUDING ANY PATENT. IT IS THE USER'S RESPONSIBILITY TO VERIFY
//  THE USER SOFTWARE DESIGN FOR CONSISTENCY AND FUNCTIONALITY THROUGH THE
//  USE OF FORMAL SOFTWARE VALIDATION METHODS.
// ------------------------------------------------------------------

#include "uart.h"
#include "pic.h"
#include "utils.h"
#include "reg_access.h"
#include <stdio.h>
#include <stdbool.h>

struct uart_instance uart_core_uart;

/* Register Macros for Motor IP */
#define NODE_MOTOR_IP_BASE_ADDR         MOTOR_CONTROLLER0_INST_AHB_LITE_SLAVE_0_MEM_MAP_BASE_ADDR
#define MTR_CTRL_MIN_RPM_REG            NODE_MOTOR_IP_BASE_ADDR + 0x00
#define MTR_CTRL_MAX_RPM_REG            NODE_MOTOR_IP_BASE_ADDR + 0x04
#define MTR_CTRL_RPM_PI_KI_REG          NODE_MOTOR_IP_BASE_ADDR + 0x08
#define MTR_CTRL_RPM_PI_KP_REG          NODE_MOTOR_IP_BASE_ADDR + 0x0C
#define MTR_CTRL_TORQUE_PI_KI_REG       NODE_MOTOR_IP_BASE_ADDR + 0x10
#define MTR_CTRL_TORQUE_PI_KP_REG       NODE_MOTOR_IP_BASE_ADDR + 0x14
#define MTR_CTRL_SYNC_DELAY_REG         NODE_MOTOR_IP_BASE_ADDR + 0x18
#define MTR_CTRL_TARGET_RPM_REG         NODE_MOTOR_IP_BASE_ADDR + 0x1C
#define MTR_CTRL_TARGET_LOCATION_REG    NODE_MOTOR_IP_BASE_ADDR + 0x20
#define MTR_CTRL_LOCATION_REG           NODE_MOTOR_IP_BASE_ADDR + 0x24

#define MTR_STATUS_RPM_REG              NODE_MOTOR_IP_BASE_ADDR + 0x28
#define MTR_STATUS_LIMIT_SW_REG         NODE_MOTOR_IP_BASE_ADDR + 0x2C
#define PRED_MNTNNCE_CTRL_REG_0         NODE_MOTOR_IP_BASE_ADDR + 0x30
#define PRED_MNTNNCE_CTRL_REG_1         NODE_MOTOR_IP_BASE_ADDR + 0x34
#define PRED_MNTNNCE_STATUS_REG         NODE_MOTOR_IP_BASE_ADDR + 0x38
#define PRED_MNTNNCE_ADC_REG_1          NODE_MOTOR_IP_BASE_ADDR + 0x3C
#define PRED_MNTNNCE_ADC_REG_2          NODE_MOTOR_IP_BASE_ADDR + 0x40
#define DIP_PUSH_BUTTON_SWITCH          NODE_MOTOR_IP_BASE_ADDR + 0x50
#define LEDS_7_SEGMENT_DISPLAY          NODE_MOTOR_IP_BASE_ADDR + 0x54

// Command identifiers
#define CMD_SET_RPM                     0x01
#define CMD_START_MOTOR                 0x02
#define CMD_STOP_MOTOR                  0x03
// Add more command identifiers as needed

// Function Prototypes
void execute_command(uint8_t command, uint32_t param);
bool validate_command(uint8_t command, uint32_t param);
void uart_isr(void *context);

// UART ISR for receiving commands
void uart_isr(void *context) {
    uint8_t received_byte;
    while (uart_receive_byte(&uart_core_uart, &received_byte)) {
        // Assume a protocol where the command byte is followed by a 4-byte parameter
        uint32_t param = 0;
        if (uart_receive_param(&uart_core_uart, &param)) {
            if (validate_command(received_byte, param)) {
                execute_command(received_byte, param);
            } else {
                // Handle invalid command or parameter here
                printf("Invalid command or parameter received.\n");
            }
        } else {
            // Error in receiving parameter bytes
            printf("Error receiving command parameter.\n");
        }
    }
}

int main(void) {
    static uint8_t idx = 0;
    static uint8_t pin_state = 0xFF;

    //initialize PIC
    pic_init(CPU0_INST_PICTIMER_START_ADDR);

    //initialize UART with interrupts enabled
    uart_core_uart.intrLevel = UART0_INST_IRQ;
    pic_isr_register(UART0_INST_IRQ, uart_isr, NULL);
    uart_init(&uart_core_uart, UART0_INST_BASE_ADDR, CPU_FREQUENCY, UART0_INST_BAUD_RATE, 1, 8);

#ifdef LSCC_STDIO_UART_APB
    extern struct uart_instance *g_stdio_uart;
    g_stdio_uart = &uart_core_uart;
#endif

    printf("Hello RISC-V world!\r\n");

    while (true) {

		// Turn on every other LED
		  reg_32b_write (LEDS_7_SEGMENT_DISPLAY, 0x5555);
		  delayMS(500);

		  // Turn on all LEDs (active low so all 0's = everything on)
		  reg_32b_write (LEDS_7_SEGMENT_DISPLAY, 0);
		  delayMS(500);

		  // Following Section F.3 from Automate Stack 1.1 Demo User Guide
		  // Set PDM offset
		  reg_32b_write (PRED_MNTNNCE_CTRL_REG_0, 0x00C80F40);
		  // Set minimum RPM
		  reg_32b_write (MTR_CTRL_MIN_RPM_REG, 0x96040078);			// control reg 0
		  // Set maximum RPM
		  reg_32b_write (MTR_CTRL_MAX_RPM_REG, 0x00000e10);			// control reg 1

		  // Set PI kI = 16 and PI Int Threshold = 64
		  reg_32b_write (MTR_CTRL_RPM_PI_KI_REG, 0x00400010);	// control reg 2
		  // Set PI kP = 128
		  reg_32b_write (MTR_CTRL_RPM_PI_KP_REG, 0x08000080);			// control reg 3

		  // Set Torque PI Int Gain (kI) = 250
		  reg_32b_write (MTR_CTRL_TORQUE_PI_KI_REG, 250);		// control reg 4
		  // Set Torque PI Control Prop Gain = 128
		  reg_32b_write (MTR_CTRL_TORQUE_PI_KP_REG, 128);		// control reg 5

		  // Set Target RPM = 200
		  reg_32b_write (MTR_CTRL_TARGET_RPM_REG, 500);			// control reg 7


		  // PI Reset Command
		  reg_32b_write (MTR_CTRL_SYNC_DELAY_REG, 0x01000000);	// control reg 6

		  // Strobe Function Command
		  unsigned int data;
			reg_32b_read (MTR_CTRL_SYNC_DELAY_REG, &data);
			reg_32b_write (MTR_CTRL_SYNC_DELAY_REG, data + 0x80000000);
			reg_32b_write (MTR_CTRL_SYNC_DELAY_REG, data);
		  // Motor Power 10% command
		  reg_32b_write (MTR_CTRL_TORQUE_PI_KP_REG, 0x00000180);

		  // Motor Start Command
		  reg_32b_write (MTR_CTRL_SYNC_DELAY_REG, 0x10000000);


		  // Strobe function
			reg_32b_read (MTR_CTRL_SYNC_DELAY_REG, &data);
			reg_32b_write (MTR_CTRL_SYNC_DELAY_REG, data + 0x80000000);
			reg_32b_write (MTR_CTRL_SYNC_DELAY_REG, data);

			  delayMS(9000);

		  // Motor Stop command
		  reg_32b_write (MTR_CTRL_SYNC_DELAY_REG, 0x12000000);

		  // Strobe function
			reg_32b_read (MTR_CTRL_SYNC_DELAY_REG, &data);
			reg_32b_write (MTR_CTRL_SYNC_DELAY_REG, data + 0x80000000);
			reg_32b_write (MTR_CTRL_SYNC_DELAY_REG, data);

    }

    return 0;
}

void execute_command(uint8_t command, uint32_t param) {
    switch (command) {
        case CMD_SET_RPM:
            reg_32b_write(MTR_CTRL_TARGET_RPM_REG, param);
            break;
        case CMD_START_MOTOR:
            reg_32b_write(MTR_CTRL_SYNC_DELAY_REG, 0x10000000);
            break;
        case CMD_STOP_MOTOR:
            reg_32b_write(MTR_CTRL_SYNC_DELAY_REG, 0x12000000);
            break;
        // Add more cases as needed
        default:
            printf("Received an unknown command.\n");
            break;
    }
}

// Validate the received command and its parameter
bool validate_command(uint8_t command, uint32_t param) {
    // Example validation: Check if the command is known and if the parameter is within an expected range
    switch (command) {
        case CMD_SET_RPM:
            return (param >= 0 && param <= 10000); // Assuming 10000 is the max RPM
        case CMD_START_MOTOR:
        case CMD_STOP_MOTOR:
            return true; // No parameter to validate for these commands
        default:
            return false; // Unknown command
    }
}
